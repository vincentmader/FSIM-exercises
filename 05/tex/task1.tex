\subsection{Unit redefinitions}
    Let us define
    \begin{equation}\label{redef1}
        \vec{r}'=\frac{\vec{r}}{\sigma} \qquad 
        E'=\frac{E}{\epsilon} \qquad 
        m'=\frac{m}{\mu}
    \end{equation}
    with $\mu=6.69\cdot 10^{-26}\mathrm{kg}$. 
    From this we can derive the following:
    \begin{align}
        \sqrt{\frac{\epsilon}{\mu}}
        =:\nu \approx 157.0 \frac{\mathrm{m}}{\mathrm{s}}
        \qquad&\Rightarrow\qquad v'=\frac{\vec{v}}{\nu}
        \label{redef_v} \\
        \frac{\sigma}{\nu}
        =:\tau \approx2.2\cdot10^{-12}\mathrm{s}
        \qquad&\Rightarrow\qquad t'=\frac{t}{\tau}
        \label{redef_t} \\
        \frac{\epsilon}{k_B}=:\theta=120\mathrm{K}
        \qquad&\Rightarrow\qquad T'=\frac{T}{\theta}
        \label{redef_T}
    \end{align}

\subsection{Particle initialization}
    First, we implement the Box-Muller-Method to get a Gaussian 
    distribution. \\
    \begin{lstlisting}
        double gaussian_rnd(void) {
            int r_1, r_2, n=32767;
            double r, phi, rand1, rand2, n_max=32767;

            rand1 = (rand() % n) / n_max;
            rand2 = (rand() % n) / n_max;

            r = sqrt(-2 * log(rand1));
            phi = 2 * 3.1415 * rand2;

            return r * cos(phi);
        }\end{lstlisting} 
    Then we initialize the velocities by drawing random numbers between 0 and 
    1 using the Gaussian distribution and multiply them with a given sigma,
    which stretches the velocity distribution. \\
    \begin{lstlisting}
        void initialize(particle *p, double L, int N1d, double sigma_v) {
            int n = 0;
            double dl = L / N1d; // L = 5*sigma N => d bar = dl = 5*sigma

            for(int i = 0; i < N1d; i++) {
              for(int j = 0; j < N1d; j++) {
                for(int k = 0; k < N1d; k++) {
                  // points on regular grid
                  p[n].pos[0] = i * dl;
                  p[n].pos[1] = j * dl;
                  p[n].pos[2] = k * dl;
                  // Gaussian-ditributed velocities
                  p[n].vel[0] = sigma_v * gaussian_rnd();
                  p[n].vel[1] = sigma_v * gaussian_rnd();
                  p[n].vel[2] = sigma_v * gaussian_rnd();

                  p[n].n_neighbors = N1d * N1d * N1d;
                  n++;
                }
              }
            }
        }\end{lstlisting}

\subsubsection{Calculating a particle's acceleration during one timestep}
    We should update our neigborlist. In our version, we put all particle as 
    neigbours.

        \begin{lstlisting}
            // This function updates the velocities by applying the accelerations 
            // for the given time interval.
            void kick(particle * p, int ntot, double dt) {
              // --- students ---
              for (int i=0; i < ntot; i++){
                for (int k=0; k<3; k++){
                  p[i].vel[k] += p[i].acc[k] * dt;
                }
              }
              // --- end ---
            }
            
            // This function drifts the particles with their velocities for the given 
            // time interval. Afterwards, the particles are mapped periodically back to 
            // the box if needed.
            void drift(particle * p, int ntot, double boxsize, double dt) {
              // --- students ---
              for (int i=0; i < ntot; i++){
                for (int k=0; k<3; k++){
                  p[i].pos[k] += p[i].vel[k] * dt;
            
                  while (p[i].pos[k] >= boxsize){
                    p[i].pos[k] -= boxsize;
                  }
                  while (p[i].pos[k] < 0){
                    p[i].pos[k] += boxsize;
                  }
                }
              }
              // --- end ---
            }
            
            // This function calculates the potentials and forces for all particles. For 
            // simplicity, we do this by going through all particle pairs i-j, and then 
            // adding the contributions both to i and j.
            void calc_forces(particle * p, int ntot, double boxsize, double rcut)
            {
              int n;
              double rcut2 = rcut * rcut;
              double r2, r, r6, r12, dr[3], acc[3], pot;
            
              // first, set all the accelerations and potentials to zero
              for (int i = 0; i < ntot; i++) {
                p[i].pot = 0;
                for (int k = 0; k < 3; k++) {
                  p[i].acc[k] = 0;
                }
                // set neighbors
                /* p[i].neighbors = p; */
              }
            
              // sum over all distinct pairs
              for (int i = 0; i < ntot; i++) {
                /* for (n = 0; n < p[i].n_neighbors; n++) { */
                /*   int j = p[i].neighbors[n]; */
                /* for (n = 0; n < p[i].n_neighbors; n++) { */
                /*   int j = p[i].neighbors[n]; */
                for (int j = 0; j < ntot; j++) {
                  /* int j = p[i].neighbors[n]; */
            
                  if (i == j) {
                    continue;
                  }
            
                  // Calculate squared distance
                  double r2 = 0;
                  for (int k = 0; k < 3; k++) {
                    dr[k] = p[i].pos[k] - p[j].pos[k];
            
                    // Ensure we find the shortest distance bewteen particles
                    if (dr[k] > 0.5 * boxsize) {
                      dr[k] -= boxsize;
                    }
            
                    if (dr[k] < -0.5 * boxsize) {
                      dr[k] += boxsize;
                    }
            
                    r2 += dr[k] * dr[k];
                  }
            
                  // --- students ---
                  if (r2 < 0.01) {
                    continue;
                  }
            
                  if (r2 < rcut2) {
                    r = sqrt(r2);
                    r6 = r2 * r2 * r2;
                    r12 = r6 * r6;
            
                    // now calculate the Lennard-Jones potential for the pair
                    pot = 4* (1 / r12 -1 /r6);
                    p[i].pot += pot;
                    /* printf("%6g", p[i].pot); */
                    /* p[j].pot += pot; */
            
                    // now calculate the Lennard-Jones force between the particles
                    for (int k = 0; k < 3; k++) {
                      // m * a = F = -grad V = 4(pos[i]-pos[j]) *(12/ r^13 - 6 /r^7)
                      acc[k] = (p[i].pos[k] - p[j].pos[k]) * (48 / (r2*r12)-24/ (r2*r6));   // VZ richitg?
                      p[i].acc[k] += acc[k];
                    }
                  }
                  // --- end ---
                }
              }
            }\end{lstlisting}

